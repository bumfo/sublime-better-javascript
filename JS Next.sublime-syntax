%YAML 1.2
---
name: JS Next
scope: source.js2

variables:
  es17_keywords: 'break|do|in|typeof|case|else|instanceof|var|catch|export|new|void|class|extends|return|while|const|finally|super|with|continue|for|switch|yield|debugger|function|this|default|if|throw|delete|import|try|await'
  es17_punctuators: '\{|\(|\)|\[|\]|\.|\.\.\.|;|,|<|>|<=|>=|==|!=|===|!==|\+|\-|\*|%|\+\+|\-\-|<<|>>|>>>|&|\||\^|!|~|&&|\|\||?|:|=|\+=|\-=|\*=|%=|<<=|>>=|>>>=|&=|\|=|\^=|=>|\*\*|\*\*=|\/|\/=|\}'
  declar_var: 'var|let|const'
  storage_classes: '{{declar_var}}|class|function|async'
  binary_operators: '!==|===|<=|>=|!=|==|=|\+=|\-=|\*=|%=|<<=|>>=|>>>=|&=|\|=|\^=|\*\*=|\/=|\*\*|\/|(?:\+)(?!\+)|(?:\-)(?!\-)|\*|%|>>>|<<|>>|<|>|&&|\|\||&|\||\^|\?|:'
  unary_operators_after: '\+\+|\-\-'
  unary_operators: '\.\.\.|!|~|\+\+|\-\-|\+|\-'
  operators: '{{binary_operators}}|{{unary_operators}}'
  punctuators: '\{|\(|\)|\[|\]|\.|;|,|=>|\}'
  identifier: '[_$[:alpha:]][_$[:alnum:]]*'
  constant_identifier: '[[:upper:]][_$[:digit:][:upper:]]*\b'
  func_lookahead: '\s*\b(async\s+)?function\b'
  arrow_func_lookahead: '\s*(\basync\s*)?([_$[:alpha:]][_$[:alnum:]]*|\([^\(]*?\))\s*=>'
  lexp_lookahead: '(?!\b(?:{{declar_var}}|{{control_keywords}})\b)[\{\(\[''"`/[:alnum:]_$]|[\.][[:digit:]]'

  control_keywords: 'break|do|case|else|catch|export|return|while|finally|with|continue|for|switch|yield|debugger|default|if|throw|import|try'

contexts:

  prototype:
    - include: comments

  main:
    - include: comments
    - include: global

  global:
    - include: statements

  import:
    - scope: keyword.control.import.js
      match: '\b(?:import)\b'
      push:
        - meta_scope: meta.import.js
        - scope: variable.other.import.default.js
          match: '(?={{identifier}})'
          set: [import-from, default-import-delimiter, import-identifier]
        - match: '(?=\*|\{)'
          set: [import-from, after-default-import]
        - match: '(?=\S)'
          pop: true

  import-identifier:
    - scope: meta.import.identifier.js
      match: '{{identifier}}(?=\s*\b(?:as)\b)'
      set: import-as
    - scope: variable.other.import.js
      match: '{{identifier}}'
      set: import-as

  default-import-delimiter:
    - match: ','
      scope: punctuation
      set:
        - match: '(?=\*|\{)'
          set: after-default-import
        - match: '(?=\S)'
          pop: true
    - match: '(?=\S)'
      pop: true

  after-default-import:
    - scope: constant.other.import.js
      match: '\*'
      set: import-as
    - scope: punctuation
      match: '\{'
      set:
        - scope: punctuation.delimiter
          match: ','
        - scope: variable.other.import.default.js
          match: '(?={{identifier}})'
          push: import-identifier
        - scope: punctuation
          match: '\}'
          pop: true
    - match: ''
      pop: true

  import-as:
    - scope: keyword.control.import.js
      match: '\b(?:as)\b'
      set:
        - scope: variable.other.identifier.js
          match: '{{identifier}}'
          pop: true
        - match: '(?=\S)'
          pop: true
    - match: '(?=\S)'
      pop: true

  import-from:
    - meta_scope: meta.import.js
    - scope: keyword.control.import.js
      match: '\b(?:from)\b'
    - match: '(?=\S)'
      pop: true

  statements:
    - include: import
    - scope: keyword.control
      match: '\b(?:{{control_keywords}})\b'
    - scope: punctuation.section.block.begin
      match: '\{'
      push:
        - scope: punctuation.section.block.end
          match: '\}'
          pop: true
        - include: statements
    - include: expressions

  unary-expressions:
    - scope: keyword.operator.unary.word
      match: '\b(?:delete|void|typeof|await)\b'
      push: unary-expression
    - scope: keyword.operator.unary
      match: '{{unary_operators}}'
      push: unary-expression

  unary-expression:
    - meta_content_scope: meta.unary-expression
    - scope: keyword.operator.unary.word
      match: '\b(?:delete|void|typeof|await)\b'
    - scope: keyword.operator.unary
      match: '{{unary_operators}}'
    - match: '(?={{lexp_lookahead}})'
      set: [after-lhs-expression, lhs-expression]
    - match: '(?=\S)'
      pop: true

  lhs-expression:
    - meta_scope: meta.lhs-expression
    - include: regexp-complete
    - include: literal-string
    - include: literal-string-template
    - include: literal-number
    - include: constant
    - scope: keyword.operator.new.js
      match: '\b(?:new)\b'
      set:
        - scope: variable.type.js
          match: '{{identifier}}'
          set:
            - match: '(?=\S)'
              pop: true
        - match: '(?=\S)'
          pop: true
    - scope: variable.function.js
      match: '{{identifier}}(?=\s*\()'
    - scope: variable.other.identifier
      match: '{{identifier}}'
      pop: true
    - scope: punctuation.section.group.begin.js
      match: '\('
      set:
        - scope: punctuation.section.group.end.js
          match: '\)'
          pop: true
        - include: expressions
    - scope: punctuation.definition.literal.array.begin.js
      match: '\['
      set:
        - scope: punctuation.definition.literal.array.end.js
          match: '\]'
          pop: true
        - include: expressions
    - scope: punctuation.definition.literal.object.begin.js
      match: '\{'
      set:
        - scope: punctuation.definition.literal.object.end.js
          match: '\}'
          pop: true
        - include: expressions
    - match: ''
      pop: true

  unary-operator-after:
    - scope: keyword.operator.unary.after
      match: '{{unary_operators_after}}'
      set: after-eol-after-lhs-expression

  binary-operators:
    - scope: keyword.operator.binary
      match: '{{binary_operators}}'
      set: unary-expression

  after-eol-after-lhs-expression:
    - meta_content_scope: meta.after-eol-after-lhs-expression
    - include: binary-operators
    - match: '(?=\S)'
      pop: true

  after-lhs-expression:
    - meta_content_scope: meta.after-lhs-expression
    - include: unary-operator-after
    - include: binary-operators
    - match: '(?=\n)'
      set: after-eol-after-lhs-expression
    - match: '(?=\S)'
      pop: true

  expressions:
    - scope: storage.type.js
      match: '\b(?:{{declar_var}})\b'
    # - scope: keyword.operator
    #   match: '{{operators}}'
    - include: unary-expressions
    - match: '(?={{lexp_lookahead}})'
      push: [after-lhs-expression, lhs-expression]
    - scope: storage.type
      match: '\b(?:{{storage_classes}})\b'
    - scope: keyword
      match: '\b(?:{{es17_keywords}})\b'
    - scope: punctuation
      match: '(?:{{punctuators}})'
  
  comments:
    - match: /\*\*(?!/)
      scope: punctuation.definition.comment.js
      push:
        - meta_scope: comment.block.documentation.js
        - match: \*/
          scope: punctuation.definition.comment.js
          pop: true
    - match: /\*
      scope: punctuation.definition.comment.js
      push:
        - meta_scope: comment.block.js
        - match: \*/
          scope: punctuation.definition.comment.js
          pop: true
    - match: '//'
      scope: punctuation.definition.comment.js
      push:
        - meta_scope: comment.line.double-slash.js
        - match: \n
          pop: true
  
  literal-string:
    - match: "'"
      scope: punctuation.definition.string.begin.js
      set:
        - meta_scope: string.quoted.single.js
        - match: (')|(\n)
          captures:
            1: punctuation.definition.string.end.js
            2: invalid.illegal.newline.js
          pop: true
        - include: string-content
    - match: '"'
      captures:
        0: punctuation.definition.string.begin.js
      set:
        - meta_scope: string.quoted.double.js
        - match: (")|(\n)
          captures:
            1: punctuation.definition.string.end.js
            2: invalid.illegal.newline.js
          pop: true
        - include: string-content

  literal-string-template:
    - match: '({{identifier}})?(`)'
      captures:
        1: variable.function.tagged-template.js
        2: punctuation.definition.string.template.begin.js
      set:
        - meta_scope: string.template.js
        - match: "`"
          scope: punctuation.definition.string.template.end.js
          pop: true
        - match: '\$\{'
          captures:
            0: punctuation.definition.template-expression.begin.js
          push:
            - meta_scope: meta.template.expression.js
            - meta_content_scope: source.js.embedded.expression
            - match: '\}'
              scope: punctuation.definition.template-expression.end.js
              pop: true
            - include: expressions
        - include: string-content

  literal-number:
    - match: '(?i)(?:\B[-+]|\b)0x[0-9a-f]*\.(\B|\b[0-9]+)'
      scope: invalid.illegal.numeric.hex.js
      pop: true
    - match: '(?:\B[-+]|\b)0[0-9]+\.(\B|\b[0-9]+)'
      scope: invalid.illegal.numeric.octal.js
      pop: true
    - match: |-
        (?xi)
        (?:\B[-+])?
        (?:
          \b0b[0-1]*|                 # binary
          \b0o[0-7]*|                 # octal
          \b0x[0-9a-f]*|              # hex
          (
            \B\.[0-9]+|               # e.g. .999
            \b[0-9]+(\.[0-9]*)?       # e.g. 999.999, 999. or 999
          )(e[-+]?[0-9]+)?            # e.g. e+123, E-123
        )
      scope: constant.numeric.js
      pop: true
    - match: '(?:\B[-+]|\b)(Infinity)\b'
      scope: constant.language.infinity.js
      pop: true

  string-content:
    - match: \\\s*\n
      scope: constant.character.escape.newline.js
    - match: '\\(x[\da-fA-F][\da-fA-F]|u[\da-fA-F][\da-fA-F][\da-fA-F][\da-fA-F]|.)'
      scope: constant.character.escape.js

  regexp-complete:
    - match: '/'
      scope: punctuation.definition.string.begin.js
      set: regexp
    # - match: '/(?=(?:[^/\\\[]|\\.|\[([^\]\\]|\\.)+\])+/(?![/*])[gimy]*(?!\s*[a-zA-Z0-9_$]))'
    #   scope: punctuation.definition.string.begin.js
    #   set: regexp

  regexp:
    - meta_scope: string.regexp.js
    - match: "(/)([gimy]*)"
      captures:
        1: punctuation.definition.string.end.js
        2: keyword.other.js
      pop: true
    - match: '(?=.|\n)'
      push:
        - match: '(?=/)'
          pop: true
        - include: scope:source.regexp.js
  
  constant:
    - match: \btrue\b
      scope: constant.language.boolean.true.js
      pop: true
    - match: \bfalse\b
      scope: constant.language.boolean.false.js
      pop: true
    - match: \bnull\b
      scope: constant.language.null.js
      pop: true
    - match: \bundefined\b
      scope: constant.language.undefined.js
      pop: true
    - match: \bNaN\b
      scope: constant.language.nan.js
      pop: true
