%YAML 1.2
---
name: JS Next
scope: source.js2

variables:
  es17_keywords: 'break|do|in|typeof|case|else|instanceof|var|catch|export|new|void|class|extends|return|while|const|finally|super|with|continue|for|switch|yield|debugger|function|this|default|if|throw|delete|import|try|await'
  es17_punctuators: '\{|\(|\)|\[|\]|\.|\.\.\.|;|,|<|>|<=|>=|==|!=|===|!==|\+|\-|\*|%|\+\+|\-\-|<<|>>|>>>|&|\||\^|!|~|&&|\|\||?|:|=|\+=|\-=|\*=|%=|<<=|>>=|>>>=|&=|\|=|\^=|=>|\*\*|\*\*=|\/|\/=|\}'
  declar_var: 'var|let|const'
  storage_classes: '{{declar_var}}|class|function|async'
  binary_operators: '!==|===|<=|>=|!=|==|=|\+=|\-=|\*=|%=|<<=|>>=|>>>=|&=|\|=|\^=|\*\*=|\/=|\*\*|\/|(?:\+)(?!\+)|(?:\-)(?!\-)|\*|%|>>>|<<|>>|<|>|&&|\|\||&|\||\^|\?|:'
  unary_operators_after: '\+\+|\-\-'
  unary_operators: '\.\.\.|!|~|\+\+|\-\-|\+|\-'
  operators: '{{binary_operators}}|{{unary_operators}}'
  punctuators: '\{|\(|\)|\[|\]|\.|;|,|=>|\}'
  identifier: '[_$[:alpha:]][_$[:alnum:]]*'
  constant_identifier: '[[:upper:]][_$[:digit:][:upper:]]*\b'
  func_lookahead: '\s*\b(async\s+)?function\b'
  arrow_func_lookahead: '\s*(\basync\s*)?([_$[:alpha:]][_$[:alnum:]]*|\([^\(]*?\))\s*=>'
  keyword_lookahead: '{{declar_var}}|{{control_keywords}}'
  lexp_lookahead: '(?<![[:alnum:]_$])(?!\b(?:{{keyword_lookahead}})\b)[\{\(\[''"`/[:alnum:]_$]|[\.][[:digit:]]'

  control_keywords: 'break|do|case|else|catch|export|return|while|finally|with|continue|for|switch|yield|debugger|default|if|throw|import|try'

contexts:

  prototype:
    - include: comments

  main:
    - include: comments
    - include: global

  global:
    - include: statements

  import:
    - scope: keyword.control.import.js
      match: '\b(?:import)\b'
      push:
        - meta_scope: meta.import.js
        - scope: variable.other.import.default.js
          match: '(?={{identifier}})'
          set: [import-from, default-import-delimiter, import-identifier]
        - match: '(?=\*|\{)'
          set: [import-from, after-default-import]
        - match: '(?=\S)'
          pop: true

  import-identifier:
    - scope: meta.import.identifier.js
      match: '{{identifier}}(?=\s*\b(?:as)\b)'
      set: import-as
    - scope: variable.other.import.js
      match: '{{identifier}}'
      set: import-as

  default-import-delimiter:
    - match: ','
      scope: punctuation
      set:
        - match: '(?=\*|\{)'
          set: after-default-import
        - match: '(?=\S)'
          pop: true
    - match: '(?=\S)'
      pop: true

  after-default-import:
    - scope: constant.other.import.js
      match: '\*'
      set: import-as
    - scope: punctuation
      match: '\{'
      set:
        - scope: punctuation.delimiter
          match: ','
        - scope: variable.other.import.default.js
          match: '(?={{identifier}})'
          push: import-identifier
        - scope: punctuation
          match: '\}'
          pop: true
    - match: ''
      pop: true

  import-as:
    - scope: keyword.control.import.js
      match: '\b(?:as)\b'
      set:
        - scope: variable.other.identifier.js
          match: '{{identifier}}'
          pop: true
        - match: '(?=\S)'
          pop: true
    - match: '(?=\S)'
      pop: true

  import-from:
    - meta_scope: meta.import.js
    - scope: keyword.control.import.js
      match: '\b(?:from)\b'
    - match: '(?=\S)'
      pop: true

  statements:
    - include: import
    - scope: keyword.control
      match: '\b(?:{{control_keywords}})\b'
    - scope: storage.type.declar.js
      match: '\b(?:{{declar_var}})\b'
    - scope: punctuation.section.block.begin
      match: '\{'
      push:
        - scope: punctuation.section.block.end
          match: '\}'
          pop: true
        - include: statements
    - scope: punctuation.terminator
      match: ';'
    - include: expressions

  unary-expressions:
    - scope: keyword.operator.unary.word
      match: '\b(?:delete|void|typeof|await)\b'
      push: unary-expression
    - scope: keyword.operator.unary
      match: '{{unary_operators}}'
      push: unary-expression
    - match: '(?={{lexp_lookahead}})'
      push: [after-lhs-expression, lhs-expression]

  unary-expression:
    - meta_content_scope: meta.unary-expression
    - scope: keyword.operator.unary.word
      match: '\b(?:delete|void|typeof|await)\b'
    - scope: keyword.operator.unary
      match: '{{unary_operators}}'
    - match: '(?={{lexp_lookahead}})'
      set: [after-lhs-expression, lhs-expression]
    - match: '(?=\S)'
      pop: true

  lhs-expression:
    - match: ''
      set: [after-call-expression, call-expression]

  after-call-expression:
    - include: after-member-expression
    - match: '(?=\S)'
      pop: true

  call-expression:
    - match: ''
      set: [call-arguments, after-member-expression, member-expression]

  call-arguments:
    - scope: punctuation.section.parens.begin
      match: '\('
      push:
        - scope: punctuation.section.parens.end
          match: '\)'
          pop: true
        - include: expressions
    - match: '(?=\S)'
      pop: true

  new-arguments:
    - scope: punctuation.section.parens.new.begin
      match: '\('
      push:
        - scope: punctuation.section.parens.new.end
          match: '\)'
          pop: true
        - include: expressions
    - match: '(?=\S)'
      pop: true

  after-member-expression:
    - scope: punctuation.section.brackets.begin
      match: '\['
      push:
        - scope: punctuation.section.brackets.end
          match: '\]'
          pop: true
        - include: expressions
    - scope: punctuation.accessor.js
      match: '\.'
      set:
        - scope: variable.function.property.js
          match: '{{identifier}}(?=\s*\()'
          set: after-member-expression
        - scope: meta.property.js
          match: '{{identifier}}'
          set: after-member-expression
        - match: '(?=\S)'
          pop: true
    - match: '(?=\S)'
      pop: true

  member-expression:
    - scope: keyword.operator.new.js
      match: '\b(?:new)\b'
      set:
        - match: '(?={{identifier}}(?:\s*\.\s*{{identifier}})*\s*(?:$|[^\[\.\w$\s]))'
          set:
            - scope: punctuation
              match: '\.'
            - scope: variable.type.js
              match: '{{identifier}}(?=\s*(?:$|[^\[\.\w$\s]))'
              set:
                - match: '(?=\S)'
                  set: new-arguments
            - scope: variable.other.js
              match: '{{identifier}}'
            - match: (?=\S)
              pop: true
        - match: '(?=\S)'
          set: [new-arguments, after-member-expression, member-expression]
    - match: ''
      set: primary-expression

  function-expression:
    - scope: storage.type.function
      match: '\b(?:function)\b'
      set:
        - match: '(?=\b(?:{{keyword_lookahead}})\b)'
          pop: true
        - scope: entity.name.function.js
          match: '{{identifier}}'
          set: formal-parameters
        - match: '(?=\S)'
          set: formal-parameters
        - match: '(?=\S)'
          pop: true

  parameter-binding-element-list-continue:
    - scope: punctuation.delimiter
      match: ','
      set: [parameter-binding-element-list-continue, parameter-binding-element]
    - match: '(?=\S)'
      pop: true

  formal-parameters-end:
    - scope: punctuation.definition.parameters.end.js
      match: '\)'
      pop: true
    - match: '(?=\S)'
      pop: true

  formal-parameters:
    - scope: punctuation.definition.parameters.begin.js
      match: '\('
      set: [formal-parameters-end, parameter-binding-element-list-continue, parameter-binding-element]
    - match: '(?=\S)'
      pop: true

  binding-array-end:
    - scope: punctuation.definition.binding-array.end.js
      match: '\]'
      set: binding-initializer
    - match: '(?=\S)'
      pop: true

  parameter-binding-element:
    - scope: punctuation.delimiter.elision
      match: ','
    - scope: punctuation.definition.binding-array.begin.js
      match: '\['
      set: [binding-array-end, parameter-binding-element-list-continue, parameter-binding-element]
    - scope: punctuation.definition.binding-object.begin.js
      match: '\{'
      set:
        - meta_scope: meta.binding.object
        - match: '(?=[\["'']|{{identifier}}\s*:)'
          push: [parameter-binding-after-property-name, object-property-name]
        - match: '(?={{identifier}})'
          push: parameter-single-name-binding
        - scope: punctuation.delimiter
          match: ','
        - scope: punctuation.definition.binding-object.end.js
          match: '\}'
          set: binding-initializer
        - match: '(?=\S)'
          pop: true
    - match: '(?={{identifier}})'
      set: parameter-single-name-binding
    - match: '(?=\S)'
      pop: true

  parameter-binding-after-property-name:
    - scope: punctuation.separator
      match: ':'
      set: parameter-binding-element
    - match: '(?=\S)'
      pop: true

  object-property-name:
    - scope: entity.name.property
      match: '{{identifier}}'
      pop: true
    - include: literal-string
    - include: literal-number
    - scope: punctuation.section.computed.begin.js
      match: '\['
      set:
        - include: assignment-expressions
        - scope: punctuation.section.computed.end.js
          match: '\]'
          pop: true
        - match: '(?=\S)'
          pop: true
    - match: '(?=\S)'
      pop: true

  binding-initializer:
    - scope: punctuation.definition.initializer
      match: '='
      set:
        - include: assignment-expressions
        - match: '(?=\S)'
          pop: true
    - match: '(?=\S)'
      pop: true

  parameter-single-name-binding:
    - scope: variable.parameter
      match: '{{identifier}}'
      set: binding-initializer
    - match: '(?=\S)'
      pop: true

  primary-expression:
    - meta_scope: meta.lhs-expression
    - include: regexp-complete
    - include: literal-string
    - include: literal-string-template
    - include: literal-number
    - include: constant
    - scope: variable.function.js
      match: '{{identifier}}(?=\s*\()'
      pop: true
    - include: function-expression
    - scope: variable.other.identifier
      match: '{{identifier}}'
      pop: true
    - scope: punctuation.section.group.begin.js
      match: '\('
      set:
        - scope: punctuation.section.group.end.js
          match: '\)'
          pop: true
        - include: expressions
    - scope: punctuation.definition.literal.array.begin.js
      match: '\['
      set:
        - scope: punctuation.definition.literal.array.end.js
          match: '\]'
          pop: true
        - include: expressions
    - scope: punctuation.definition.literal.object.begin.js
      match: '\{'
      set:
        - scope: punctuation.definition.literal.object.end.js
          match: '\}'
          pop: true
        - include: expressions
    - match: ''
      pop: true

  unary-operator-after:
    - scope: keyword.operator.unary.after
      match: '{{unary_operators_after}}'
      set: after-eol-after-lhs-expression

  binary-operators:
    - scope: keyword.operator.binary
      match: '{{binary_operators}}'
      set: unary-expression

  after-eol-after-lhs-expression:
    # - meta_content_scope: meta.after-eol-after-lhs-expression
    - include: binary-operators
    - match: '(?=\S)'
      pop: true

  after-lhs-expression:
    # - meta_content_scope: meta.after-lhs-expression
    - include: unary-operator-after
    - include: binary-operators
    - match: '(?=\n)'
      set: after-eol-after-lhs-expression
    - match: '(?=\S)'
      pop: true

  assignment-expressions:
    - include: unary-expressions

  expressions:
    - scope: punctuation.delimiter
      match: ','
    - include: assignment-expressions
    # - scope: storage.type
    #   match: '\b(?:{{storage_classes}})\b'
    # - scope: keyword
    #   match: '\b(?:{{es17_keywords}})\b'
    # - scope: punctuation
    #   match: '(?:{{punctuators}})'
    # - scope: keyword.operator
    #   match: '{{operators}}'
  
  comments:
    - match: /\*\*(?!/)
      scope: punctuation.definition.comment.js
      push:
        - meta_scope: comment.block.documentation.js
        - match: \*/
          scope: punctuation.definition.comment.js
          pop: true
    - match: /\*
      scope: punctuation.definition.comment.js
      push:
        - meta_scope: comment.block.js
        - match: \*/
          scope: punctuation.definition.comment.js
          pop: true
    - match: '//'
      scope: punctuation.definition.comment.js
      push:
        - meta_scope: comment.line.double-slash.js
        - match: \n
          pop: true
  
  literal-string:
    - match: "'"
      scope: punctuation.definition.string.begin.js
      set:
        - meta_scope: string.quoted.single.js
        - match: (')|(\n)
          captures:
            1: punctuation.definition.string.end.js
            2: invalid.illegal.newline.js
          pop: true
        - include: string-content
    - match: '"'
      captures:
        0: punctuation.definition.string.begin.js
      set:
        - meta_scope: string.quoted.double.js
        - match: (")|(\n)
          captures:
            1: punctuation.definition.string.end.js
            2: invalid.illegal.newline.js
          pop: true
        - include: string-content

  literal-string-template:
    - match: '({{identifier}})?(`)'
      captures:
        1: variable.function.tagged-template.js
        2: punctuation.definition.string.template.begin.js
      set:
        - meta_scope: string.template.js
        - match: "`"
          scope: punctuation.definition.string.template.end.js
          pop: true
        - match: '\$\{'
          captures:
            0: punctuation.definition.template-expression.begin.js
          push:
            - meta_scope: meta.template.expression.js
            - meta_content_scope: source.js.embedded.expression
            - match: '\}'
              scope: punctuation.definition.template-expression.end.js
              pop: true
            - include: expressions
        - include: string-content

  literal-number:
    - match: '(?i)(?:\B[-+]|\b)0x[0-9a-f]*\.(\B|\b[0-9]+)'
      scope: invalid.illegal.numeric.hex.js
      pop: true
    - match: '(?:\B[-+]|\b)0[0-9]+\.(\B|\b[0-9]+)'
      scope: invalid.illegal.numeric.octal.js
      pop: true
    - match: |-
        (?xi)
        (?:\B[-+])?
        (?:
          \b0b[0-1]*|                 # binary
          \b0o[0-7]*|                 # octal
          \b0x[0-9a-f]*|              # hex
          (
            \B\.[0-9]+|               # e.g. .999
            \b[0-9]+(\.[0-9]*)?       # e.g. 999.999, 999. or 999
          )(e[-+]?[0-9]+)?            # e.g. e+123, E-123
        )
      scope: constant.numeric.js
      pop: true
    - match: '(?:\B[-+]|\b)(Infinity)\b'
      scope: constant.language.infinity.js
      pop: true

  string-content:
    - match: \\\s*\n
      scope: constant.character.escape.newline.js
    - match: '\\(x[\da-fA-F][\da-fA-F]|u[\da-fA-F][\da-fA-F][\da-fA-F][\da-fA-F]|.)'
      scope: constant.character.escape.js

  regexp-complete:
    - match: '/'
      scope: punctuation.definition.string.begin.js
      set: regexp
    # - match: '/(?=(?:[^/\\\[]|\\.|\[([^\]\\]|\\.)+\])+/(?![/*])[gimy]*(?!\s*[a-zA-Z0-9_$]))'
    #   scope: punctuation.definition.string.begin.js
    #   set: regexp

  regexp:
    - meta_scope: string.regexp.js
    - match: "(/)([gimy]*)"
      captures:
        1: punctuation.definition.string.end.js
        2: keyword.other.js
      pop: true
    - match: '(?=.|\n)'
      push:
        - match: '(?=/)'
          pop: true
        - include: scope:source.regexp.js
  
  constant:
    - match: \btrue\b
      scope: constant.language.boolean.true.js
      pop: true
    - match: \bfalse\b
      scope: constant.language.boolean.false.js
      pop: true
    - match: \bnull\b
      scope: constant.language.null.js
      pop: true
    - match: \bundefined\b
      scope: constant.language.undefined.js
      pop: true
    - match: \bNaN\b
      scope: constant.language.nan.js
      pop: true
