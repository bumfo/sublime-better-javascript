%YAML 1.2
---
name: JS Next
scope: source.js

file_extensions:
  - js
  - mjs
  - jsx

variables:
  es17_keywords: 'break|do|in|typeof|case|else|instanceof|var|catch|export|new|void|class|extends|return|while|const|finally|super|with|continue|for|switch|yield|debugger|function|this|default|if|throw|delete|import|try|await'
  es17_punctuators: '\{|\(|\)|\[|\]|\.|\.\.\.|;|,|<|>|<=|>=|==|!=|===|!==|\+|\-|\*|%|\+\+|\-\-|<<|>>|>>>|&|\||\^|!|~|&&|\|\||?|:|=|\+=|\-=|\*=|%=|<<=|>>=|>>>=|&=|\|=|\^=|=>|\*\*|\*\*=|\/|\/=|\}'
  declar_var: 'var|let|const|static'
  class_keyword: 'class|struct'
  storage_classes: '{{declar_var}}|class|function|async'
  binary_operators_word: '\b(?:instanceof|in)\b(?!\$)'
  binary_operators: '!==|===|<=|>=|!=|==|=|\+=|\-=|\*=|%=|<<=|>>=|>>>=|&=|\|=|\^=|\*\*=|\/=|\*\*|\/|(?:\+)(?!\+)|(?:\-)(?!\-)|\*|%|>>>|<<|>>|<|>|&&|\|\||&|\||\^|{{binary_operators_word}}' #|\?|:
  ternary_operators: '\?|:'
  unary_operators_word: '\b(?:delete|void|typeof|await)\b(?!\$)'
  unary_operators_after: '\+\+|\-\-'
  unary_operators: '\.\.\.|!|~|\+\+|\-\-|\+|\-'
  operators: '{{ternary_operators}}|{{binary_operators}}|{{unary_operators}}'
  punctuators: '\{|\(|\)|\[|\]|\.|;|,|=>|\}'
  identifier: '[_$[:alpha:]][_$[:alnum:]]*'
  constant_identifier: '[[:upper:]][_$[:digit:][:upper:]]*\b'
  func_lookahead: '\s*\b(async\s+)?function\b'
  arrow_func_lookahead: '(?:[_$[:alpha:]][_$[:alnum:]]*|\([^\(]*?\))\s*=>'
  keyword_lookahead: '{{declar_var}}|{{control_keywords}}'
  lexp_lookahead: '(?!\b(?:{{keyword_lookahead}})\b)[\{\(\[''"`/[:alnum:]_$]|[\.][[:digit:]]|{{jsx_lookahead}}|{{decorator_lookahead}}' #(?<![[:alnum:]_$])

  number_lookahead: '[0-9]+'
  property_name_lookahead: '[\["'']|(?:{{identifier}}|{{number_lookahead}})'

  control_keywords: 'break|do|case|else|catch|export|return|while|finally|with|continue|for|switch|yield|debugger|default|if|throw|import|try'



  jsx_lookahead: '(?=</?{{identifier}})'
  jsx_attribute_key: '[a-zA-Z_][a-zA-Z_\-0-9]*'

  decorator_lookahead: '(?=@)'


  attribute_name: '[a-zA-Z_\-][a-zA-Z0-9_\-]*(?![a-zA-Z0-9_\-])'

contexts:

  prototype:
    - include: comments

  main:
    - include: comments
    - include: global

  global:
    - include: statements

  meta-export:
    - meta_content_scope: meta.export.js
    - match: ''
      pop: true

  export-brace:
    - scope: punctuation.delimiter
      match: ','
    - scope: variable.other.default.js
      match: '(?={{identifier}})'
      push: export-identifier
    - scope: punctuation.export.begin.js
      match: '\}'
      pop: true

  export-statements:
    - scope: keyword.control.export.js
      match: '\b(?:export)\b'
      push:
        - meta_scope: meta.export.js
        - scope: constant.other.export.js
          match: '\*'
          set: [meta-export, export-from, export-as]
        - scope: punctuation.export.begin
          match: '\{'
          set: [meta-export, export-from, export-brace]
        - scope: keyword.control.export.default.js
          match: '\b(?:default)\b'
          set: [meta-export, expression]
        - match: '(?=\S)'
          pop: true

  export-identifier:
    - scope: storage.export.default.js
      match: '\b(?:default)\b'
      set: export-as
    - scope: variable.other.export.js
      match: '{{identifier}}(?=\s*\b(?:as)\b)'
      set: export-as
    - scope: meta.identifier.export.js
      match: '{{identifier}}'
      set: export-as

  export-as:
    - scope: keyword.control.export.as.js
      match: '\b(?:as)\b'
      set:
        - scope: storage.export.default.js
          match: '\b(?:default)\b'
          pop: true
        - scope: meta.identifier.export.js
          match: '{{identifier}}'
          pop: true
        - match: '(?=\S)'
          pop: true
    - match: '(?=\S)'
      pop: true

  string:
    - include: literal-string
    - match: '(?=\S)'
      pop: true

  export-from:
    - scope: keyword.control.export.js
      match: '\b(?:from)\b'
      set: string
    - match: '(?=\S)'
      pop: true

  import-statements:
    - scope: keyword.control.import.js
      match: '\b(?:import)\b'
      push:
        - meta_scope: meta.import.js
        - match: '(?=\b(?:{{es17_keywords}})\b)'
          pop: true
        - scope: variable.other.import.default.js
          match: '(?={{identifier}})'
          set: [meta-import, import-from, default-import-delimiter, import-identifier]
        - match: '(?=\*|\{)'
          set: [meta-import, import-from, after-default-import]
        - match: '(?=\S)'
          pop: true

  meta-import:
    - meta_content_scope: meta.import.js
    - match: ''
      pop: true

  import-identifier:
    - scope: storage.import.default.js
      match: '\b(?:default)\b'
      set: import-as
    - scope: meta.import.identifier.js
      match: '{{identifier}}(?=\s*\b(?:as)\b)'
      set: import-as
    - scope: variable.other.import.js
      match: '{{identifier}}'
      set: import-as

  default-import-delimiter:
    - match: ','
      scope: punctuation
      set:
        - match: '(?=\*|\{)'
          set: after-default-import
        - match: '(?=\S)'
          pop: true
    - match: '(?=\S)'
      pop: true

  after-default-import:
    - scope: constant.other.import.js
      match: '\*'
      set: import-as
    - scope: punctuation
      match: '\{'
      set:
        - scope: punctuation.delimiter
          match: ','
        - scope: variable.other.import.js
          match: '(?={{identifier}})'
          push: import-identifier
        - scope: punctuation
          match: '\}'
          pop: true
    - match: ''
      pop: true

  import-as:
    - scope: keyword.control.import.as.js
      match: '\b(?:as)\b'
      set:
        - scope: variable.other.identifier.js
          match: '{{identifier}}'
          pop: true
        - match: '(?=\S)'
          pop: true
    - match: '(?=\S)'
      pop: true

  import-from:
    - scope: keyword.control.import.js
      match: '\b(?:from)\b'
      set: string
    - match: '(?=\S)'
      pop: true

  statements:
    - include: import-statements
    - include: export-statements
    - include: variable-statements
    - include: let-or-const-statements
    - include: for-statements
    - include: return-statements
    - include: switch-statements
    - scope: keyword.control
      match: '\b(?:{{control_keywords}})\b'
    - scope: storage.type.declar.js
      match: '\b(?:{{declar_var}})\b'
    - include: statement-groups
    - scope: punctuation.terminator
      match: ';'
    - include: expressions

  statement-groups:
    - scope: punctuation.section.block.begin
      match: '\{'
      push:
        - meta_scope: meta.block.js
        - scope: punctuation.section.block.end
          match: '\}'
          pop: true
        - include: statements

  statement-group:
    - scope: punctuation.section.block.begin
      match: '\{'
      set:
        - meta_scope: meta.block.js
        - scope: punctuation.section.block.end
          match: '\}'
          pop: true
        - include: statements
    - match: '(?=\S)'
      pop: true

  switch-statements:
    - scope: keyword.control.switch.js
      match: '\b(?:switch)\b'
      push: switch-parens

  switch-parens:
    - scope: punctuation.definition.group.begin.js
      match: '\('
      push:
        - meta_scope: meta.switch-parens
        - scope: punctuation.definition.group.end.js
          match: '\)'
          pop: true
        - match: (?=\S)
          push: expression
    - match: '(?=\S)'
      set: swicth-brace

  swicth-brace:
    - scope: punctuation.definition.switch-block.begin.js
      match: '\{'
      set:
        - meta_scope: meta.switch-parens
        - scope: keyword.case
          match: '\b(?:case)\b'
          push: [after-case, expression]
        - scope: keyword.default
          match: '\b(?:default)\b'
          push: after-case
        - include: statement-groups
        - scope: punctuation.definition.switch-block.end.js
          match: '\}'
          pop: true
    - match: '(?=\S)'
      pop: true

  after-case:
    - scope: punctuation.colon
      match: ':'
      set:
        - match: '(?=\b(?:case|default)\b)'
          pop: true
        - include: statements
        - match: '(?=\S)'
          pop: true
    - match: '(?=\S)'
      pop: true

  variable-statements:
    - scope: meta.variable-declaration.js storage.type.var.js
      match: '\b(?:var)\b'
      push: [variable-declaration-list-continue, variable-declaration]

  variable-statement:
    - scope: meta.variable-declaration.js storage.type.var.js
      match: '\b(?:var)\b'
      set: [variable-declaration-list-continue, variable-declaration]

  let-or-const-statements:
    - scope: meta.variable-declaration.js storage.type.let.js
      match: '\b(?:let)\b'
      push: [variable-declaration-list-continue, variable-declaration]
    - scope: meta.variable-declaration.js storage.type.const.js
      match: '\b(?:const)\b'
      push: [variable-declaration-list-continue, variable-declaration]
  
  let-or-const-statement:
    - scope: meta.variable-declaration.js storage.type.let.js
      match: '\b(?:let)\b'
      set: [variable-declaration-list-continue, variable-declaration]
    - scope: meta.variable-declaration.js storage.type.const.js
      match: '\b(?:const)\b'
      set: [variable-declaration-list-continue, variable-declaration]

  variable-declaration-list-continue:
    - meta_content_scope: meta.variable-declaration.js
    - scope: punctuation.delimiter
      match: ','
      set: [variable-declaration-list-continue, variable-declaration]
    - match: '(?=\S)'
      pop: true

  variable-declaration:
    - match: '(?=\b(?:{{keyword_lookahead}}|function|class)\b)'
      pop: true
    - match: '(?={{identifier}})'
      set: variable-binding-identifier
    - include: variable-binding-pattern
    - match: '(?=\S)'
      pop: true

  variable-binding-pattern:
    - scope: punctuation.definition.binding-array.begin.js
      match: '\['
      set: [binding-array-end, variable-declaration-list-continue, variable-declaration]
    - scope: punctuation.definition.binding-object.begin.js
      match: '\{'
      set:
        - meta_scope: meta.binding.object
        - match: '(?={{property_name_lookahead}}\s*:)'
          push: [variable-binding-after-property-name, object-property-name]
        - match: '(?={{identifier}})'
          push: variable-binding-identifier
        - scope: punctuation.delimiter
          match: ','
        - scope: punctuation.definition.binding-object.end.js
          match: '\}'
          set: binding-initializer
        - match: '(?=\S)'
          pop: true

  variable-binding-after-property-name:
    - scope: punctuation.separator
      match: ':'
      set: variable-declaration
    - match: '(?=\S)'
      pop: true

  variable-binding-identifier:
    - scope: variable.other.declaration
      match: '{{identifier}}'
      set: binding-initializer
    - match: '(?=\S)'
      pop: true

  binding-array-end:
    - scope: punctuation.definition.binding-array.end.js
      match: '\]'
      set: binding-initializer
    - match: '(?=\S)'
      pop: true

  binding-initializer:
    # - scope: punctuation.definition.initializer
    - scope: keyword.operator.initializer.js
      match: '='
      set: assignment-expression
    - match: '(?=\S)'
      pop: true

  return-statements:
    - scope: keyword.control.return.js
      match: '\b(?:return)\b'
      push: expression

  for-statements:
    - scope: keyword.control.for.js
      match: '\b(?:for)\b'
      push: for-group

  for-group:
    - scope: punctuation.definition.group.begin.js
      match: '\('
      push:
        - meta_scope: meta.for-group
        - scope: punctuation.definition.group.end.js
          match: '\)'
          pop: true
        - match: '(?=\b(?:var)\b)'
          push: [for-expression-start, variable-statement]
        - match: '(?=\b(?:let|const)\b)'
          push: [for-expression-start, let-or-const-statement]
        - match: (?=\S)
          push: [for-expression-start, expression]
    - match: '(?=\S)'
      pop: true

  for-expression-start:
    - scope: keyword.operator.in
      match: '\b(?:in)\b'
      set: for-expression-after-in
    - scope: keyword.operator.of
      match: '\b(?:of)\b'
      set: for-expression-after-of
    - scope: punctuation.terminator.for.js
      match: ';'
      set: for-expression-after-one-semicolon
    - match: '(?=\S)'
      pop: true

  for-expression-after-one-semicolon:
    - scope: punctuation.terminator.for.js
      match: ';'
      set: for-expression-after-two-semicolon
    - include: expressions
    - match: '(?=\S)'
      pop: true

  for-expression-after-two-semicolon:
    - include: expressions
    - match: '(?=\S)'
      pop: true

  for-expression-after-in:
    - include: expressions
    - match: '(?=\S)'
      pop: true

  for-expression-after-of:
    - scope: invalid.illegal.js
      match: ','
    - include: assignment-expressions
    - match: '(?=\S)'
      pop: true

  unary-expressions:
    - scope: keyword.operator.unary.word
      match: '{{unary_operators_word}}'
      push: unary-expression
    - scope: keyword.operator.unary
      match: '{{unary_operators}}'
      push: unary-expression
    - match: '(?={{lexp_lookahead}})'
      push: [after-lhs-expression, lhs-expression]

  unary-expression:
    - meta_content_scope: meta.unary-expression
    - scope: keyword.operator.unary.word
      match: '{{unary_operators_word}}'
    - scope: keyword.operator.unary
      match: '{{unary_operators}}'
    - match: '(?={{lexp_lookahead}})'
      set: [after-lhs-expression, lhs-expression]
    - match: '(?=\S)'
      pop: true

  lhs-expression:
    - match: ''
      set: [after-call-expression, call-expression]

  unary-operator-after:
    - scope: keyword.operator.unary.after
      match: '{{unary_operators_after}}'
      set: after-eol-after-lhs-expression

  binary-operator:
    - scope: keyword.operator.binary
      match: '{{binary_operators}}'
      set: unary-expression

  conditional-operator:
    - scope: keyword.operator.ternary
      match: '\?'
      push: [unary-expression, after-conditional-operator]

  after-conditional-operator:
    - include: unary-expressions
    - scope: keyword.operator.ternary
      match: ':'
      pop: true
    - match: '(?=\S)'
      pop: true

  after-eol-after-lhs-expression:
    # - meta_content_scope: meta.after-eol-after-lhs-expression
    - meta_content_scope: meta.expression.after-eol.js
    - include: binary-operator
    - include: conditional-operator
    - match: '(?=\S)'
      pop: true

  after-lhs-expression:
    # - meta_content_scope: meta.after-lhs-expression
    - meta_content_scope: meta.expression.js
    - include: unary-operator-after
    - include: binary-operator
    - include: conditional-operator
    - match: '(?=\n)'
      set: after-eol-after-lhs-expression
    - match: '(?=\S)'
      pop: true

  after-call-expression:
    - scope: punctuation.section.brackets.begin
      match: '\['
      push:
        - scope: punctuation.section.brackets.end
          match: '\]'
          pop: true
        - include: expressions
    - scope: punctuation.accessor.js
      match: '\.'
      set:
        - meta_scope: meta.property-accessor
        - scope: variable.function.property.js
          match: '{{identifier}}(?=\s*\()'
          set: after-call-expression
        - scope: meta.property.js
          match: '{{identifier}}'
          set: after-call-expression
        - match: '(?=\S)'
          pop: true
    - include: cover-call-arguments-and-arrow-function
    # - match: '(?=\S)'
    #   pop: true
  
  after-member-expression:
    - scope: punctuation.section.brackets.begin
      match: '\['
      push:
        - scope: punctuation.section.brackets.end
          match: '\]'
          pop: true
        - include: expressions
    - scope: punctuation.accessor.js
      match: '\.'
      set:
        - meta_scope: meta.property-accessor
        - scope: variable.function.property.js
          match: '{{identifier}}(?=\s*\()'
          set: after-member-expression
        - scope: meta.property.js
          match: '{{identifier}}'
          set: after-member-expression
        - match: '(?=\S)'
          pop: true
    - match: '(?=\S)'
      pop: true

  new-after-member-expression:
    - scope: punctuation.accessor.js
      match: '\.'
      set:
        - meta_scope: meta.new-property-accessor
        - scope: variable.type.js
          match: '{{identifier}}(?=\s*\()'
          set: new-after-member-expression
        - scope: variable.type.maybe.js
          match: '{{identifier}}'
          set: new-after-member-expression
        - match: '(?=\S)'
          pop: true
    - include: after-member-expression

  call-expression:
    - match: ''
      set: [cover-call-arguments-and-arrow-function, after-member-expression, member-expression]

  cover-call-arguments-and-arrow-function:
    - include: arrow-function
    - include: call-arguments

  call-arguments:
    - scope: punctuation.section.parens.begin
      match: '\('
      push:
        - meta_scope: meta.arguments.js
        - scope: punctuation.section.parens.end
          match: '\)'
          pop: true
        - include: expressions
    - match: '(?=\S)'
      pop: true

  new-arguments:
    - scope: punctuation.section.parens.begin
      match: '\('
      push:
        - meta_scope: meta.arguments.new.js
        - scope: punctuation.section.parens.end
          match: '\)'
          pop: true
        - include: expressions
    - match: '(?=\S)'
      pop: true

  new-member-expression:
    - scope: variable.type.js
      match: '(?!\b(?:{{keyword_lookahead}}|function|class)\b){{identifier}}(?=\s*\()'
      pop: true
    - scope: variable.type.maybe.js
      match: '(?!\b(?:{{keyword_lookahead}}|function|class)\b){{identifier}}'
      pop: true
    - include: member-expression

  member-expression:
    - scope: keyword.operator.new.js
      match: '\b(?:new)\b'
      set:
        - match: '(?=\S)'
          set: [new-arguments, new-after-member-expression, new-member-expression]
    - match: ''
      set: primary-expression

  object-literal-delimiter:
    - scope: punctuation.delimiter
      match: ','
      pop: true
    # - scope: invalid.illegal
    #   match: '[^{}()\s:]+'
    #   pop: true
    - match: '(?={{identifier}})'
      set:
        - scope: invalid.illegal
          match: '{{identifier}}(?=\s*\()'
          set: [object-literal-delimiter, statement-group, formal-parameters]
        - scope: invalid.illegal
          match: '{{identifier}}'
          set: 
            - scope: invalid.illegal
              match: ':'
              set: [object-literal-delimiter, assignment-expression]
            - include: object-literal-after-property-name
        - match: '(?=\S)'
          pop: true
    - match: '(?=\S)'
      pop: true

  object-literal-after-property-name:
    - scope: punctuation.separator
      match: ':'
      set: [object-literal-delimiter, assignment-expression]
    - match: '(?=\()'
      set: [object-literal-delimiter, statement-group, formal-parameters]
    - match: '(?=\S)'
      pop: true

  async-in-object-literal:
    - scope: storage.type.async.js
      match: '\b(?:async(?!\s*\())\b'
      push:
        - scope: entity.name.function.async.js
          match: '{{identifier}}'
          set: [object-literal-delimiter, statement-group, formal-parameters]
        - match: '(?=\S)'
          set: formal-parameters

  object-literal:
    - scope: punctuation.definition.literal.object.begin.js
      match: '\{'
      set: object-literal-content

  object-literal-content:
    - meta_scope: meta.object.js
    - match: '(?={{identifier}})'
      push:
        - include: async-in-object-literal
        - scope: entity.name.function.class.js
          match: '{{identifier}}(?=\s*\()'
          set: [object-literal-delimiter, statement-group, formal-parameters]
        - scope: entity.name.property-variable
          match: '{{identifier}}(?=\s*,)'
          set: [object-literal-delimiter]
        - scope: meta.identifier.property
          match: '{{identifier}}(?=\s*:)'
          set: object-literal-after-property-name
        - scope: storage.type.accessor.get.js
          match: '\b(?:get)\b'
          set:
            - scope: entity.name.function.getter.js
              match: '{{identifier}}'
              set: [object-literal-delimiter, statement-group, formal-parameters]
            - match: '(?=\S)'
              pop: true
        - scope: storage.type.accessor.set.js
          match: '\b(?:set)\b'
          set:
            - scope: entity.name.function.setter.js
              match: '{{identifier}}'
              set: [object-literal-delimiter, statement-group, formal-parameters]
            - match: '(?=\S)'
              pop: true
        - scope: meta.identifier
          match: '{{identifier}}'
          set: object-literal-after-property-name
        - match: '(?=\S)'
          pop: true
    - match: '(?={{property_name_lookahead}})'
      push: [object-literal-after-property-name, object-property-name]
    - scope: keyword.generator.asterisk.js
      match: '\*'
      push:
        - scope: entity.name.function.generator.js
          match: '{{identifier}}'
          set: [object-literal-delimiter, statement-group, formal-parameters]
        - match: '(?=\S)'
          pop: true
    - scope: invalid.illegal.js
      match: ':'
      push: [object-literal-delimiter, assignment-expression]
    - include: statement-groups
    - scope: punctuation.definition.literal.object.end.js
      match: '\}'
      pop: true

  primary-expression:
    - include: jsx-expression
    - include: regexp-complete
    - include: literal-string
    - include: literal-string-template
    - include: literal-number
    - include: constant
    - include: function-expression
    - include: class-expression
    - include: decorator
    - scope: variable.function.js
      match: '(?<![[:alnum:]_$]){{identifier}}(?=\s*\()'
      pop: true
    - scope: variable.function.struct.js
      match: '(?<![[:alnum:]_$]){{identifier}}(?=\s*\{)'
      set: object-literal
    - scope: variable.other.identifier
      match: '(?<![[:alnum:]_$]){{identifier}}'
      pop: true
    - scope: punctuation.section.group.begin.js
      match: '\('
      set:
        - meta_scope: meta.group.js
        - scope: punctuation.section.group.end.js
          match: '\)'
          pop: true
        - include: expressions
    - scope: punctuation.definition.literal.array.begin.js
      match: '\['
      set:
        - meta_scope: meta.array.js
        - scope: punctuation.definition.literal.array.end.js
          match: '\]'
          pop: true
        - include: expressions
    - include: object-literal
    - match: ''
      pop: true

  function-expression:
    - scope: storage.type.async.js
      match: '\b(?:async)\b'
      set:
        - scope: storage.type.function
          match: '\b(?:function)\b'
          set:
            - match: '(?=\b(?:{{keyword_lookahead}})\b)'
              pop: true
            - scope: entity.name.function.async.js
              match: '{{identifier}}'
              set: [statement-group, formal-parameters]
            - match: '(?=\S)'
              set: [statement-group, formal-parameters]
        - include: arrow-function
        - match: '(?=\S)'
          pop: true
    - scope: storage.type.function
      match: '\b(?:function)\b'
      set:
        - scope: keyword.generator.asterisk.js
          match: '\*'
          set:
            - match: '(?=\b(?:{{keyword_lookahead}})\b)'
              pop: true
            - scope: entity.name.function.generator.js
              match: '{{identifier}}'
              set: [statement-group, formal-parameters]
            - match: '(?=\S)'
              set: [statement-group, formal-parameters]
        - match: '(?=\b(?:{{keyword_lookahead}})\b)'
          pop: true
        - scope: entity.name.function.js
          match: '{{identifier}}'
          set: [statement-group, formal-parameters]
        - match: '(?=\S)'
          set: [statement-group, formal-parameters]
    - include: arrow-function

  arrow-function:
    - match: '(?={{arrow_func_lookahead}})'
      set: 
        - match: '(?=\()'
          set: [arrow-function-tail, formal-parameters]
        - scope: variable.parameter.function.arrow.js
          match: '{{identifier}}'
          set: [arrow-function-tail, formal-parameters]
        - match: ''
          pop: true

  arrow-function-tail:
    - scope: storage.type.function.arrow.js
      match: '=>'
      set:
        - match: '(?=\{)'
          set: statement-group
        - match: '(?=\S)'
          set: unary-expression
    - match: '(?=\S)'
      pop: true

  parameter-binding-element-list-continue:
    - scope: punctuation.delimiter
      match: ','
      set: [parameter-binding-element-list-continue, parameter-binding-element]
    - match: '(?=\S)'
      pop: true

  formal-parameters-end:
    - meta_scope: meta.parameters.js
    - scope: punctuation.definition.parameters.end.js
      match: '\)'
      pop: true
    - match: '(?=\S)'
      pop: true

  formal-parameters:
    - scope: punctuation.definition.parameters.begin.js
      match: '\('
      set: [formal-parameters-end, parameter-binding-element-list-continue, parameter-binding-element]
    - match: '(?=\S)'
      pop: true

  parameter-binding-element:
    - scope: punctuation.definition.rest
      match: '\.\.\.'
      set: parameter-binding-element
    - scope: invalid.illegal
      match: '\.'
    - scope: punctuation.delimiter.elision
      match: ','
    - match: '(?={{identifier}})'
      set: parameter-single-name-binding
    - include: parameter-binding-pattern
    - match: '(?=\S)'
      pop: true

  parameter-binding-pattern:
    - scope: punctuation.definition.binding-array.begin.js
      match: '\['
      set: [binding-array-end, parameter-binding-element-list-continue, parameter-binding-element]
    - scope: punctuation.definition.binding-object.begin.js
      match: '\{'
      set:
        - meta_scope: meta.binding.object
        - match: '(?={{property_name_lookahead}}\s*:)'
          push: [parameter-binding-after-property-name, object-property-name]
        - match: '(?={{identifier}})'
          push: parameter-single-name-binding
        - scope: punctuation.delimiter
          match: ','
        - scope: punctuation.definition.binding-object.end.js
          match: '\}'
          set: binding-initializer
        - match: '(?=\S)'
          pop: true

  parameter-binding-after-property-name:
    - scope: punctuation.separator
      match: ':'
      set: parameter-binding-element
    - match: '(?=\S)'
      pop: true

  object-property-name:
    - scope: entity.name.property
      match: '{{identifier}}'
      pop: true
    - include: literal-string
    - include: literal-number
    - scope: entity.name.function.const-computed
      match: '(\[)\s*({{identifier}})\s*(\])(?=\s*\()'
      captures:
        1: punctuation.section.computed.begin.js
        # 2: entity.name.function.const-computed
        3: punctuation.section.computed.end.js
      pop: true
    - match: '(\[)(?=\s*(?:{{identifier}}\s*(?:\.\s*{{identifier}}\s*)+)(?:\])(?:\s*\())'
      captures:
        1: punctuation.section.computed.begin.js
      set:
        - meta_scope: entity.name.function.const-computed
        - scope: punctuation.accessor.js
          match: '\.'
        - scope: punctuation.section.computed.end.js
          match: '\]'
          pop: true
    - scope: punctuation.section.computed.begin.js
      match: '\['
      set:
        - include: assignment-expressions
        - scope: punctuation.section.computed.end.js
          match: '\]'
          pop: true
        - match: '(?=\S)'
          pop: true
    - match: '(?=\S)'
      pop: true

  parameter-single-name-binding:
    - scope: variable.parameter
      match: '{{identifier}}'
      set: binding-initializer
    - match: '(?=\S)'
      pop: true

  class-expression:
    - scope: storage.type.class
      match: '\b(?:{{class_keyword}})\b'
      set:
        - scope: entity.name.type.class.js
          match: '{{identifier}}'
          set: class-tail
        - match: '(?=\S)'
          set: class-tail

  class-tail:
    - scope: storage.modifier.extends.js
      match: '\b(?:extends)\b'
      set: [class-body, extends-expression]        
    - match: '(?=\S)'
      set: class-body

  extends-expression:
    - scope: punctuation
      match: '\.'
    - match: '(?={{es17_keywords}})'
      set: expression
    - scope: entity.other.inherited-class.js
      match: '{{identifier}}'
      set: extends-expression-after-name
    - match: '(?=\S)'
      set: expression

  extends-expression-after-name:
    - match: '(?=\{)'
      pop: true
    - scope: punctuation
      match: '\.'
      set: extends-expression-after-dot
    - match: '(?=\S)'
      set: after-member-expression

  extends-expression-after-dot:
    - match: '(?=\{)'
      pop: true
    - scope: entity.other.inherited-class.js
      match: '{{identifier}}'
      set: extends-expression-after-name

  class-body:
    - match: '(?=\()'
      set: [class-body-pure, formal-parameters]
    - match: '(?=\{)'
      set: class-body-pure
    - match: '(?=\S)'
      pop: true

  class-body-pure:
    - scope: punctuation.definition.block.begin.js
      match: '\{'
      set: 
        - meta_scope: meta.class.js
        - include: class-body-content
        - scope: punctuation.definition.block.end.js
          match: '\}'
          pop: true
    - match: '(?=\S)'
      pop: true

  class-body-content:
    - scope: punctuation.terminator
      match: ';'
    - scope: storage.type.static.js
      match: '\b(?:static)\b'
    - include: decorators
    - include: class-method-or-field-definitions

  class-method-or-field-definitions:
    - match: '(?={{identifier}})'
      push:
        - scope: entity.name.function.class.js
          match: '{{identifier}}(?=\s*\()'
          set: formal-parameters
        - scope: storage.type.accessor.get.js
          match: '\b(?:get)\b'
          set:
            - scope: entity.name.function.getter.js
              match: '{{identifier}}'
              set: formal-parameters
            - match: '(?=\S)'
              pop: true
        - scope: storage.type.accessor.set.js
          match: '\b(?:set)\b'
          set:
            - scope: entity.name.function.setter.js
              match: '{{identifier}}'
              set: formal-parameters
            - match: '(?=\S)'
              pop: true
        - scope: storage.type.async.js
          match: '\b(?:async)\b'
          set:
            - scope: entity.name.function.async.js
              match: '{{identifier}}'
              set: formal-parameters
            - match: '(?=\S)'
              pop: true
        - scope: meta.identifier
          match: '{{identifier}}'
          set:
            # - scope: punctuation.separator
            #   match: ','
            #   pop: true
            - match: '(?=[=])'
              set: binding-initializer
            - match: '(?=\S)'
              pop: true
    - match: (?={{property_name_lookahead}}\s*\()
      push: [formal-parameters, object-property-name]
    - scope: keyword.generator.asterisk.js
      match: '\*'
      push:
        - scope: entity.name.function.generator.js
          match: '{{identifier}}'
          set: formal-parameters
        - match: '(?=\S)'
          pop: true
    - include: statement-groups

  assignment-expression:
    - match: ''
      set: unary-expression

  assignment-expressions:
    - include: unary-expressions

  expression:
    - scope: punctuation.delimiter
      match: ','
    - include: assignment-expression

  expressions:
    - scope: punctuation.delimiter
      match: ','
    - include: assignment-expressions
    # - scope: storage.type
    #   match: '\b(?:{{storage_classes}})\b'
    # - scope: keyword
    #   match: '\b(?:{{es17_keywords}})\b'
    # - scope: punctuation
    #   match: '(?:{{punctuators}})'
    # - scope: keyword.operator
    #   match: '{{operators}}'
  
  comments:
    - match: /\*\*(?!/)
      scope: punctuation.definition.comment.js
      push:
        - meta_scope: comment.block.documentation.js
        - match: \*/
          scope: punctuation.definition.comment.js
          pop: true
    - match: /\*
      scope: punctuation.definition.comment.js
      push:
        - meta_scope: comment.block.js
        - match: \*/
          scope: punctuation.definition.comment.js
          pop: true
    - match: '//'
      scope: punctuation.definition.comment.js
      push:
        - meta_scope: comment.line.double-slash.js
        - match: \n
          pop: true
  
  literal-string:
    - match: "'"
      scope: punctuation.definition.string.begin.js
      set:
        - meta_scope: string.quoted.single.js
        - meta_include_prototype: false
        - match: (')|(\n)
          captures:
            1: punctuation.definition.string.end.js
            2: invalid.illegal.newline.js
          pop: true
        - include: string-content
    - match: '"'
      captures:
        0: punctuation.definition.string.begin.js
      set:
        - meta_scope: string.quoted.double.js
        - meta_include_prototype: false
        - match: (")|(\n)
          captures:
            1: punctuation.definition.string.end.js
            2: invalid.illegal.newline.js
          pop: true
        - include: string-content

  literal-string-template:
    - match: '({{identifier}})?(`)'
      captures:
        1: variable.function.tagged-template.js
        2: punctuation.definition.string.template.begin.js
      set:
        - meta_scope: string.template.js
        - meta_include_prototype: false
        - match: "`"
          scope: punctuation.definition.string.template.end.js
          pop: true
        - match: '\$\{'
          captures:
            0: punctuation.definition.template-expression.begin.js
          push:
            - meta_scope: meta.template.expression.js
            - meta_content_scope: source.js.embedded.expression
            - match: '\}'
              scope: punctuation.definition.template-expression.end.js
              pop: true
            - include: expressions
        - include: string-content

  literal-number:
    - match: '(?i)(?:\B[-+]|\b)0x[0-9a-f]*\.(\B|\b[0-9]+)'
      scope: invalid.illegal.numeric.hex.js
      pop: true
    - match: '(?:\B[-+]|\b)0[0-9]+\.(\B|\b[0-9]+)'
      scope: invalid.illegal.numeric.octal.js
      pop: true
    - match: |-
        (?xi)
        (?:\B[-+])?
        (?:
          \b0b[0-1]*|                 # binary
          \b0o[0-7]*|                 # octal
          \b0x[0-9a-f]*|              # hex
          (
            \B\.[0-9]+|               # e.g. .999
            \b[0-9]+(\.[0-9]*)?       # e.g. 999.999, 999. or 999
          )(e[-+]?[0-9]+)?            # e.g. e+123, E-123
        )
        (?![[:alnum:]_$])
      scope: constant.numeric.js
      pop: true
    - match: '(?:\B[-+]|\b)(Infinity)\b'
      scope: constant.language.infinity.js
      pop: true

  string-content:
    - meta_include_prototype: false
    - match: \\\s*\n
      scope: constant.character.escape.newline.js
    - match: '\\(x[\da-fA-F][\da-fA-F]|u[\da-fA-F][\da-fA-F][\da-fA-F][\da-fA-F]|.)'
      scope: constant.character.escape.js

  regexp-complete:
    - match: '/'
      scope: punctuation.definition.string.begin.js
      set: regexp
    # - match: '/(?=(?:[^/\\\[]|\\.|\[([^\]\\]|\\.)+\])+/(?![/*])[gimy]*(?!\s*[a-zA-Z0-9_$]))'
    #   scope: punctuation.definition.string.begin.js
    #   set: regexp

  regexp:
    - meta_scope: string.regexp.js
    - match: "(/)([gimy]*)"
      captures:
        1: punctuation.definition.string.end.js
        2: keyword.other.js
      pop: true
    - match: '(?=.|\n)'
      push:
        - match: '(?=/)'
          pop: true
        - include: scope:source.regexp.js
  
  constant:
    - match: \btrue\b
      scope: constant.language.boolean.true.js
      pop: true
    - match: \bfalse\b
      scope: constant.language.boolean.false.js
      pop: true
    - match: \bnull\b
      scope: constant.language.null.js
      pop: true
    - match: \bundefined\b
      scope: constant.language.undefined.js
      pop: true
    - match: \bNaN\b
      scope: constant.language.nan.js
      pop: true




  jsx-expression:
    - scope: meta.jsx-expression
      match: '(</)({{identifier}})'
      captures:
        1: punctuation.definition.tag.begin.html
        2: meta.tag.block.any.html entity.name.tag.block.any.html
      set: jsx-after-close-tag-name
    - scope: meta.jsx-expression
      match: '(<)({{identifier}})'
      captures:
        1: punctuation.definition.tag.begin.html
        2: meta.tag.block.any.html entity.name.tag.block.any.html
      set: jsx-after-open-tag-name

  jsx-tag:
    - include: jsx-injections
    - match: '(?=<{{identifier}})'
      push: jsx-expression
    - match: '(?=</{{identifier}})'
      pop: true

  jsx-after-open-tag-name:
    - meta_content_scope: meta.jsx
    - include: jsx-attributes
    - include: jsx-injections
    - scope: punctuation.definition.tag.end.html
      match: '/>'
      pop: true
    - scope: punctuation.definition.tag.end.html
      match: '>'
      set: [jsx-expression, jsx-tag]

  jsx-after-close-tag-name:
    - meta_content_scope: meta.jsx
    - scope: punctuation.definition.tag.end.html
      match: '>'
      pop: true

  jsx-injections:
    - match: '(?=\{)'
      push: jsx-injection

  jsx-injection:
    - scope: punctuation.definition.jsx-injection
      match: '\{'
      set: 
        - scope: punctuation.definition.jsx-injection
          match: '\}'
          pop: true
        - include: expressions

  jsx-attributes:
    - match: '(?={{jsx_attribute_key}})'
      push: jsx-attribute

  jsx-attribute:
    - scope: entity.other.attribute-name
      match: '{{jsx_attribute_key}}'
      set:
        - scope: punctuation.separator.key-value
          match: '='
          set:
            - match: '(?=")'
              set: literal-string
            - match: '(?=\S)'
              pop: true
        - match: '(?=\S)'
          pop: true


  decorator-meta:
    - meta_content_scope: meta.decorator
    - match: ''
      pop: true

  decorator-puncutation:
    - scope: punctuation.definition.decorator
      match: '@'
      pop: true

  decorators:
    - match: '(?=@)'
      push: decorator

  decorator:
    - include: vue-component-decorator
    - match: '(?=@)'
      set: [decorator-meta, lhs-expression, decorator-puncutation]



  vue-component-decorator:
    - match: '(@)(Component)(?=\()'
      captures:
        1: punctuation.definition.decorator
        2: variable.function.decorator
      set:
        - scope: punctuation.section.parens.begin
          match: '\('
          set:
            - scope: punctuation.definition.literal.object.begin.js
              match: '\{'
              push: 
                - meta_scope: meta.object.component.js
                - match: '\b(template)\b(:)'
                  captures:
                    1: meta.identifier.property
                    2: punctuation.separator
                  push: [object-literal-delimiter, vue-template-expression]
                - include: object-literal-content
            - include: expressions
            - scope: punctuation.section.parens.end
              match: '\)'
              pop: true

  vue-template-expression:
    - scope: punctuation.definition.string.vue-template.begin.js
      match: '(?=`)'
      push: [vue-template-content-end, vue-template-content-context, vue-template-content-begin]
    - match: '(?=\S)'
      pop: true
    #   set: assignment-expression

  vue-template-contents:
    - meta_content_scope: text.html.embedded
    - match: '(?=`)'
      pop: true
    # - include: scope:text.html.basic

    - include: other-tags

  vue-template-content-context:
    - match: ''
      set: vue-template-contents
      # with_prototype:
      #   - match: '(?=`)'
      #     pop: true

  vue-template-content-begin:
    - scope: punctuation.definition.string.vue-template.begin.js
      match: '`'
      pop: true


  vue-template-content-end:
    - scope: punctuation.definition.string.vue-template.end.js
      match: '`'
      pop: true


  other-tags:
    - match: '(<)(?:([a-zA-Z0-9:]+)\b)'
      captures:
        1: punctuation.definition.tag.begin.html
        2: entity.name.tag.other.html
      push: [meta-other-begin, tag-stuff]
    - match: '(</)(?:([a-zA-Z0-9:]+)\b)'
      captures:
        1: punctuation.definition.tag.begin.html
        2: entity.name.tag.other.html
      push: [meta-other-begin, tag-end]

  meta-other-begin:
    - meta_scope: meta.tag.other.begin.html
    - match: ''
      pop: true

  tag-stuff:
    - include: tag-stuff-vue-attributes
    - include: tag-stuff-other-attributes
    - include: tag-end

  tag-stuff-other-attributes:
    - scope: entity.other.attribute-name.html
      match: '{{attribute_name}}'
      push: tag-stuff-attribute-punctuation-and-value

  tag-stuff-attribute-punctuation-and-value:
    - scope: punctuation.separator.key-value.html
      match: '='
      set:
        - scope: punctuation.definition.string.begin.html
          match: '"'
          set:
            - meta_scope: string.quoted.double.html
            - scope: punctuation.definition.string.end.html
              match: '"'
              pop: true
        - scope: string.unquoted.html
          match: '{{attribute_name}}(?!\s*=)'
          pop: true
        - match: '(?=\S)'
          pop: true
    - match: '(?=\S)'
      pop: true

  tag-end:
    - scope: punctuation.definition.tag.end.html
      match: '>'
      pop: true

  tag-stuff-vue-attributes:
    - scope: entity.other.attribute-name.html storage.type
      match: '(@){{attribute_name}}'
      captures:
        1: punctuation.vue.on
      push: [tag-stuff-attribute-punctuation-and-js-expr-value, tag-stuff-modifier]
    - scope: entity.other.attribute-name.html keyword.vue.directives
      match: 'v-(?:for|if|show|model)'
      push: tag-stuff-attribute-punctuation-and-js-expr-value
    - scope: entity.other.attribute-name.html meta.vue.v-bind
      match: '(:){{attribute_name}}'
      captures:
        1: punctuation.vue.expr
      push: [tag-stuff-attribute-punctuation-and-js-expr-value, tag-stuff-modifier]

  tag-stuff-modifier:
    - match: '(\.)([a-zA-Z]+)'
      captures:
        1: punctuation
        2: keyword.other.modifier
    - match: '(?=\S)'
      pop: true

  tag-stuff-attribute-punctuation-and-js-expr-value:
    - scope: punctuation.separator.key-value.html
      match: '='
      set:
        - scope: punctuation.definition.string.begin.html
          match: '"'
          set: [end-double-quote, js-expr-double-quoted-content]
          # with_prototype:
          #   - match: '(?=")'
          #     pop: true
        - scope: string.unquoted.html
          match: '{{attribute_name}}(?!\s*=)'
          pop: true
        - match: '(?=\S)'
          pop: true
    - match: '(?=\S)'
      pop: true

  js-expr-double-quoted-content:
    - meta_scope: meta.string.quoted.double.html
    - match: '(?=")'
      pop: true
    - include: js-expr-contents

  end-double-quote:
    - scope: punctuation.definition.string.end.html
      match: '"'
      pop: true

  js-expr-contents:
    - meta_content_scope: source.js.embedded.html
    - include: expressions
