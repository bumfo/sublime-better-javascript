%YAML 1.2
---
name: JS Next
scope: source.js2

variables:
  es17_keywords: 'break|do|in|typeof|case|else|instanceof|var|catch|export|new|void|class|extends|return|while|const|finally|super|with|continue|for|switch|yield|debugger|function|this|default|if|throw|delete|import|try|await'
  es17_punctuators: '\{|\(|\)|\[|\]|\.|\.\.\.|;|,|<|>|<=|>=|==|!=|===|!==|\+|\-|\*|%|\+\+|\-\-|<<|>>|>>>|&|\||\^|!|~|&&|\|\||?|:|=|\+=|\-=|\*=|%=|<<=|>>=|>>>=|&=|\|=|\^=|=>|\*\*|\*\*=|\/|\/=|\}'
  declar_var: 'var|let|const'
  storage_classes: '{{declar_var}}|class|function|async'
  binary_operators: '!==|===|<=|>=|!=|==|=|\+=|\-=|\*=|%=|<<=|>>=|>>>=|&=|\|=|\^=|\*\*=|\/=|\*\*|\/|(?:\+)(?!\+)|(?:\-)(?!\-)|\*|%|>>>|<<|>>|<|>|&&|\|\||&|\||\^|\?|:'
  unary_operators_after: '\+\+|\-\-'
  unary_operators: '\.\.\.|!|~|\+\+|\-\-|\+|\-'
  operators: '{{binary_operators}}|{{unary_operators}}'
  punctuators: '\{|\(|\)|\[|\]|\.|;|,|=>|\}'
  identifier: '[_$[:alpha:]][_$[:alnum:]]*'
  constant_identifier: '[[:upper:]][_$[:digit:][:upper:]]*\b'
  func_lookahead: '\s*\b(async\s+)?function\b'
  arrow_func_lookahead: '(?:[_$[:alpha:]][_$[:alnum:]]*|\([^\(]*?\))\s*=>'
  keyword_lookahead: '{{declar_var}}|{{control_keywords}}'
  lexp_lookahead: '(?<![[:alnum:]_$])(?!\b(?:{{keyword_lookahead}})\b)[\{\(\[''"`/[:alnum:]_$]|[\.][[:digit:]]'

  number_lookahead: '[0-9]+'
  property_name_lookahead: '[\["'']|(?:{{identifier}}|{{number_lookahead}})'

  control_keywords: 'break|do|case|else|catch|export|return|while|finally|with|continue|for|switch|yield|debugger|default|if|throw|import|try'

contexts:

  prototype:
    - include: comments

  main:
    - include: comments
    - include: global

  global:
    - include: statements

  import-statements:
    - scope: keyword.control.import.js
      match: '\b(?:import)\b'
      push:
        - meta_scope: meta.import.js
        - scope: variable.other.import.default.js
          match: '(?={{identifier}})'
          set: [import-from, default-import-delimiter, import-identifier]
        - match: '(?=\*|\{)'
          set: [import-from, after-default-import]
        - match: '(?=\S)'
          pop: true

  import-identifier:
    - scope: meta.import.identifier.js
      match: '{{identifier}}(?=\s*\b(?:as)\b)'
      set: import-as
    - scope: variable.other.import.js
      match: '{{identifier}}'
      set: import-as

  default-import-delimiter:
    - match: ','
      scope: punctuation
      set:
        - match: '(?=\*|\{)'
          set: after-default-import
        - match: '(?=\S)'
          pop: true
    - match: '(?=\S)'
      pop: true

  after-default-import:
    - scope: constant.other.import.js
      match: '\*'
      set: import-as
    - scope: punctuation
      match: '\{'
      set:
        - scope: punctuation.delimiter
          match: ','
        - scope: variable.other.import.default.js
          match: '(?={{identifier}})'
          push: import-identifier
        - scope: punctuation
          match: '\}'
          pop: true
    - match: ''
      pop: true

  import-as:
    - scope: keyword.control.import.js
      match: '\b(?:as)\b'
      set:
        - scope: variable.other.identifier.js
          match: '{{identifier}}'
          pop: true
        - match: '(?=\S)'
          pop: true
    - match: '(?=\S)'
      pop: true

  import-from:
    - meta_scope: meta.import.js
    - scope: keyword.control.import.js
      match: '\b(?:from)\b'
    - match: '(?=\S)'
      pop: true

  statements:
    - include: import-statements
    - include: variable-statements
    - include: let-or-const-statements
    - include: for-statements
    - scope: keyword.control
      match: '\b(?:{{control_keywords}})\b'
    - scope: storage.type.declar.js
      match: '\b(?:{{declar_var}})\b'
    - include: statement-groups
    - scope: punctuation.terminator
      match: ';'
    - include: expressions

  statement-groups:
    - scope: punctuation.section.block.begin
      match: '\{'
      push:
        - meta_scope: meta.block.js
        - scope: punctuation.section.block.end
          match: '\}'
          pop: true
        - include: statements

  statement-group:
    - scope: punctuation.section.block.begin
      match: '\{'
      set:
        - meta_scope: meta.block.js
        - scope: punctuation.section.block.end
          match: '\}'
          pop: true
        - include: statements

  variable-statements:
    - scope: meta.variable-declaration.js storage.type.var.js
      match: '\b(?:var)\b'
      push: [variable-declaration-list-continue, variable-declaration]

  variable-statement:
    - scope: meta.variable-declaration.js storage.type.var.js
      match: '\b(?:var)\b'
      set: [variable-declaration-list-continue, variable-declaration]

  let-or-const-statements:
    - scope: meta.variable-declaration.js storage.type.let.js
      match: '\b(?:let)\b'
      push: [variable-declaration-list-continue, variable-declaration]
    - scope: meta.variable-declaration.js storage.type.const.js
      match: '\b(?:const)\b'
      push: [variable-declaration-list-continue, variable-declaration]
  
  let-or-const-statement:
    - scope: meta.variable-declaration.js storage.type.let.js
      match: '\b(?:let)\b'
      set: [variable-declaration-list-continue, variable-declaration]
    - scope: meta.variable-declaration.js storage.type.const.js
      match: '\b(?:const)\b'
      set: [variable-declaration-list-continue, variable-declaration]

  variable-declaration-list-continue:
    - meta_content_scope: meta.variable-declaration.js
    - scope: punctuation.delimiter
      match: ','
      set: [variable-declaration-list-continue, variable-declaration]
    - match: '(?=\S)'
      pop: true

  variable-declaration:
    - match: '(?=\b(?:{{keyword_lookahead}}|function|class)\b)'
      pop: true
    - match: '(?={{identifier}})'
      set: variable-binding-identifier
    - include: variable-binding-pattern
    - match: '(?=\S)'
      pop: true

  variable-binding-pattern:
    - scope: punctuation.definition.binding-array.begin.js
      match: '\['
      set: [binding-array-end, variable-declaration-list-continue, variable-declaration]
    - scope: punctuation.definition.binding-object.begin.js
      match: '\{'
      set:
        - meta_scope: meta.binding.object
        - match: '(?={{property_name_lookahead}}\s*:)'
          push: [variable-binding-after-property-name, object-property-name]
        - match: '(?={{identifier}})'
          push: variable-binding-identifier
        - scope: punctuation.delimiter
          match: ','
        - scope: punctuation.definition.binding-object.end.js
          match: '\}'
          set: binding-initializer
        - match: '(?=\S)'
          pop: true

  variable-binding-after-property-name:
    - scope: punctuation.separator
      match: ':'
      set: variable-declaration
    - match: '(?=\S)'
      pop: true

  variable-binding-identifier:
    - scope: variable.other.declaration
      match: '{{identifier}}'
      set: binding-initializer
    - match: '(?=\S)'
      pop: true

  binding-array-end:
    - scope: punctuation.definition.binding-array.end.js
      match: '\]'
      set: binding-initializer
    - match: '(?=\S)'
      pop: true

  binding-initializer:
    # - scope: punctuation.definition.initializer
    - scope: keyword.operator.initializer.js
      match: '='
      set: assignment-expression
    - match: '(?=\S)'
      pop: true

  for-statements:
    - scope: keyword.control.for.js
      match: '\b(?:for)\b'
      push: for-group

  for-group:
    - scope: punctuation.definition.group.begin.js
      match: '\('
      push:
        - meta_scope: meta.for-group
        - scope: punctuation.definition.group.end.js
          match: '\)'
          pop: true
        - match: '(?=\b(?:var)\b)'
          push: [for-expression-start, variable-statement]
        - match: '(?=\b(?:let)\b)'
          push: [for-expression-start, let-or-const-statement]
        - match: (?=\S)
          push: [for-expression-start, expression]
    - match: '(?=\S)'
      pop: true

  for-expression-start:
    - scope: keyword.operator.in
      match: '\b(?:in)\b'
      set: for-expression-after-in
    - scope: keyword.operator.of
      match: '\b(?:of)\b'
      set: for-expression-after-of
    - scope: punctuation.terminator.for.js
      match: ';'
      set: for-expression-after-one-semicolon
    - match: '(?=\S)'
      pop: true

  for-expression-after-one-semicolon:
    - scope: punctuation.terminator.for.js
      match: ';'
      set: for-expression-after-two-semicolon
    - include: expressions
    - match: '(?=\S)'
      pop: true

  for-expression-after-two-semicolon:
    - include: expressions
    - match: '(?=\S)'
      pop: true

  for-expression-after-in:
    - include: expressions
    - match: '(?=\S)'
      pop: true

  for-expression-after-of:
    - scope: invalid.illegal.js
      match: ','
    - include: assignment-expressions
    - match: '(?=\S)'
      pop: true

  unary-expressions:
    - scope: keyword.operator.unary.word
      match: '\b(?:delete|void|typeof|await)\b'
      push: unary-expression
    - scope: keyword.operator.unary
      match: '{{unary_operators}}'
      push: unary-expression
    - match: '(?={{lexp_lookahead}})'
      push: [after-lhs-expression, lhs-expression]

  unary-expression:
    - meta_content_scope: meta.unary-expression
    - scope: keyword.operator.unary.word
      match: '\b(?:delete|void|typeof|await)\b'
    - scope: keyword.operator.unary
      match: '{{unary_operators}}'
    - match: '(?={{lexp_lookahead}})'
      set: [after-lhs-expression, lhs-expression]
    - match: '(?=\S)'
      pop: true

  lhs-expression:
    - match: ''
      set: [after-call-expression, call-expression]

  unary-operator-after:
    - scope: keyword.operator.unary.after
      match: '{{unary_operators_after}}'
      set: after-eol-after-lhs-expression

  binary-operators:
    - scope: keyword.operator.binary
      match: '{{binary_operators}}'
      set: unary-expression

  after-eol-after-lhs-expression:
    # - meta_content_scope: meta.after-eol-after-lhs-expression
    - meta_content_scope: meta.expression.after-eol.js
    - include: binary-operators
    - match: '(?=\S)'
      pop: true

  after-lhs-expression:
    # - meta_content_scope: meta.after-lhs-expression
    - meta_content_scope: meta.expression.js
    - include: unary-operator-after
    - include: binary-operators
    - match: '(?=\n)'
      set: after-eol-after-lhs-expression
    - match: '(?=\S)'
      pop: true

  after-call-expression:
    - scope: punctuation.section.brackets.begin
      match: '\['
      push:
        - scope: punctuation.section.brackets.end
          match: '\]'
          pop: true
        - include: expressions
    - scope: punctuation.accessor.js
      match: '\.'
      set:
        - meta_scope: meta.property-accessor
        - scope: variable.function.property.js
          match: '{{identifier}}(?=\s*\()'
          set: after-call-expression
        - scope: meta.property.js
          match: '{{identifier}}'
          set: after-call-expression
        - match: '(?=\S)'
          pop: true
    - include: cover-call-arguments-and-arrow-function
    # - match: '(?=\S)'
    #   pop: true
  
  after-member-expression:
    - scope: punctuation.section.brackets.begin
      match: '\['
      push:
        - scope: punctuation.section.brackets.end
          match: '\]'
          pop: true
        - include: expressions
    - scope: punctuation.accessor.js
      match: '\.'
      set:
        - meta_scope: meta.property-accessor
        - scope: variable.function.property.js
          match: '{{identifier}}(?=\s*\()'
          set: after-member-expression
        - scope: meta.property.js
          match: '{{identifier}}'
          set: after-member-expression
        - match: '(?=\S)'
          pop: true
    - match: '(?=\S)'
      pop: true

  new-after-member-expression:
    - scope: punctuation.accessor.js
      match: '\.'
      set:
        - meta_scope: meta.new-property-accessor
        - scope: variable.type.js
          match: '{{identifier}}(?=\s*\()'
          set: new-after-member-expression
        - scope: variable.type.maybe.js
          match: '{{identifier}}'
          set: new-after-member-expression
        - match: '(?=\S)'
          pop: true
    - include: after-member-expression

  call-expression:
    - match: ''
      set: [cover-call-arguments-and-arrow-function, after-member-expression, member-expression]

  cover-call-arguments-and-arrow-function:
    - include: arrow-function
    - include: call-arguments

  call-arguments:
    - scope: punctuation.section.parens.begin
      match: '\('
      push:
        - meta_scope: meta.arguments.js
        - scope: punctuation.section.parens.end
          match: '\)'
          pop: true
        - include: expressions
    - match: '(?=\S)'
      pop: true

  new-arguments:
    - scope: punctuation.section.parens.begin
      match: '\('
      push:
        - meta_scope: meta.arguments.new.js
        - scope: punctuation.section.parens.end
          match: '\)'
          pop: true
        - include: expressions
    - match: '(?=\S)'
      pop: true

  new-member-expression:
    - scope: variable.type.js
      match: '(?!\b(?:{{keyword_lookahead}}|function|class)\b){{identifier}}(?=\s*\()'
      pop: true
    - scope: variable.type.maybe.js
      match: '(?!\b(?:{{keyword_lookahead}}|function|class)\b){{identifier}}'
      pop: true
    - include: member-expression

  member-expression:
    - scope: keyword.operator.new.js
      match: '\b(?:new)\b'
      set:
        - match: '(?=\S)'
          set: [new-arguments, new-after-member-expression, new-member-expression]
    - match: ''
      set: primary-expression

  primary-expression:
    # - meta_scope: meta.primary-expression
    - include: regexp-complete
    - include: literal-string
    - include: literal-string-template
    - include: literal-number
    - include: constant
    - include: function-expression
    - include: class-expression
    - scope: variable.function.js
      match: '{{identifier}}(?=\s*\()'
      pop: true
    - scope: variable.other.identifier
      match: '{{identifier}}'
      pop: true
    - scope: punctuation.section.group.begin.js
      match: '\('
      set:
        - meta_scope: meta.group.js
        - scope: punctuation.section.group.end.js
          match: '\)'
          pop: true
        - include: expressions
    - scope: punctuation.definition.literal.array.begin.js
      match: '\['
      set:
        - meta_scope: meta.array.js
        - scope: punctuation.definition.literal.array.end.js
          match: '\]'
          pop: true
        - include: expressions
    - scope: punctuation.definition.literal.object.begin.js
      match: '\{'
      set:
        - meta_scope: meta.object.js
        - scope: punctuation.definition.literal.object.end.js
          match: '\}'
          pop: true
        - include: expressions
    - match: ''
      pop: true

  function-expression:
    - scope: storage.type.async.js
      match: '\b(?:async)\b'
      set:
        - scope: storage.type.function
          match: '\b(?:function)\b'
          set:
            - match: '(?=\b(?:{{keyword_lookahead}})\b)'
              pop: true
            - scope: entity.name.function.async.js
              match: '{{identifier}}'
              set: formal-parameters
            - match: '(?=\S)'
              set: formal-parameters
        - include: arrow-function
        - match: '(?=\S)'
          pop: true
    - scope: storage.type.function
      match: '\b(?:function)\b'
      set:
        - scope: keyword.generator.asterisk.js
          match: '\*'
          set:
            - match: '(?=\b(?:{{keyword_lookahead}})\b)'
              pop: true
            - scope: entity.name.function.generator.js
              match: '{{identifier}}'
              set: formal-parameters
            - match: '(?=\S)'
              set: formal-parameters
        - match: '(?=\b(?:{{keyword_lookahead}})\b)'
          pop: true
        - scope: entity.name.function.js
          match: '{{identifier}}'
          set: formal-parameters
        - match: '(?=\S)'
          set: formal-parameters
    - include: arrow-function

  arrow-function:
    - match: '(?={{arrow_func_lookahead}})'
      set: 
        - match: '(?=\()'
          set: [arrow-function-tail, formal-parameters]
        - scope: variable.parameter.function.arrow.js
          match: '{{identifier}}'
          set: [arrow-function-tail, formal-parameters]
        - match: ''
          pop: true

  arrow-function-tail:
    - scope: storage.type.function.arrow.js
      match: '=>'
      set:
        - match: '(?=\{)'
          set: statement-group
        - match: '(?=\S)'
          set: unary-expression
    - match: '(?=\S)'
      pop: true

  parameter-binding-element-list-continue:
    - scope: punctuation.delimiter
      match: ','
      set: [parameter-binding-element-list-continue, parameter-binding-element]
    - match: '(?=\S)'
      pop: true

  formal-parameters-end:
    - meta_scope: meta.parameters.js
    - scope: punctuation.definition.parameters.end.js
      match: '\)'
      pop: true
    - match: '(?=\S)'
      pop: true

  formal-parameters:
    - scope: punctuation.definition.parameters.begin.js
      match: '\('
      set: [formal-parameters-end, parameter-binding-element-list-continue, parameter-binding-element]
    - match: '(?=\S)'
      pop: true

  parameter-binding-element:
    - scope: punctuation.definition.rest
      match: '\.\.\.'
      set: parameter-binding-element
    - scope: invalid.illegal
      match: '\.'
    - scope: punctuation.delimiter.elision
      match: ','
    - match: '(?={{identifier}})'
      set: parameter-single-name-binding
    - include: parameter-binding-pattern
    - match: '(?=\S)'
      pop: true

  parameter-binding-pattern:
    - scope: punctuation.definition.binding-array.begin.js
      match: '\['
      set: [binding-array-end, parameter-binding-element-list-continue, parameter-binding-element]
    - scope: punctuation.definition.binding-object.begin.js
      match: '\{'
      set:
        - meta_scope: meta.binding.object
        - match: '(?={{property_name_lookahead}}\s*:)'
          push: [parameter-binding-after-property-name, object-property-name]
        - match: '(?={{identifier}})'
          push: parameter-single-name-binding
        - scope: punctuation.delimiter
          match: ','
        - scope: punctuation.definition.binding-object.end.js
          match: '\}'
          set: binding-initializer
        - match: '(?=\S)'
          pop: true

  parameter-binding-after-property-name:
    - scope: punctuation.separator
      match: ':'
      set: parameter-binding-element
    - match: '(?=\S)'
      pop: true

  object-property-name:
    - scope: entity.name.property
      match: '{{identifier}}'
      pop: true
    - include: literal-string
    - include: literal-number
    - scope: punctuation.section.computed.begin.js
      match: '\['
      set:
        - include: assignment-expressions
        - scope: punctuation.section.computed.end.js
          match: '\]'
          pop: true
        - match: '(?=\S)'
          pop: true
    - match: '(?=\S)'
      pop: true

  parameter-single-name-binding:
    - scope: variable.parameter
      match: '{{identifier}}'
      set: binding-initializer
    - match: '(?=\S)'
      pop: true

  class-expression:
    - scope: storage.type.class
      match: '\b(?:class)\b'
      set:
        - scope: entity.name.type.class.js
          match: '{{identifier}}'
          set: class-tail
        - match: '(?=\S)'
          set: class-tail

  class-tail:
    - scope: storage.modifier.extends.js
      match: '\b(?:extends)\b'
      set: 
        - scope: entity.other.inherited-class.js
          match: '{{identifier}}'
          set: class-body
        - match: '(?=\S)'
          set: class-body
    - match: '(?=\S)'
      set: class-body

  class-body:
    - scope: punctuation.definition.block.begin.js
      match: '\{'
      push:
        - meta_scope: meta.class.js
        - scope: punctuation.terminator
          match: ';'
        - scope: storage.type.static.js
          match: '\b(?:static)\b'
        - include: class-method-definitions
        - scope: punctuation.definition.block.end.js
          match: '\}'
          pop: true
    - match: '(?=\S)'
      pop: true

  class-method-definitions:
    - match: '(?={{identifier}})'
      push:
        - scope: entity.name.function.class.js
          match: '{{identifier}}(?=\s*\()'
          set: formal-parameters
        - scope: storage.type.accessor.get.js
          match: '\b(?:get)\b'
          set:
            - scope: entity.name.function.getter.js
              match: '{{identifier}}'
              set: formal-parameters
            - match: '(?=\S)'
              pop: true
        - scope: storage.type.accessor.set.js
          match: '\b(?:set)\b'
          set:
            - scope: entity.name.function.setter.js
              match: '{{identifier}}'
              set: formal-parameters
            - match: '(?=\S)'
              pop: true
        - scope: storage.type.async.js
          match: '\b(?:async)\b'
          set:
            - scope: entity.name.function.async.js
              match: '{{identifier}}'
              set: formal-parameters
            - match: '(?=\S)'
              pop: true
        - scope: meta.identifier
          match: '{{identifier}}'
          set:
            - match: '(?=[=])'
              set: binding-initializer
            - match: '(?=\S)'
              pop: true
    - match: (?={{property_name_lookahead}}\s*\()
      push: [formal-parameters, object-property-name]
    - scope: keyword.generator.asterisk.js
      match: '\*'
      push:
        - scope: entity.name.function.generator.js
          match: '{{identifier}}'
          set: formal-parameters
        - match: '(?=\S)'
          pop: true
    - include: statement-groups

  assignment-expression:
    - match: ''
      set: unary-expression

  assignment-expressions:
    - include: unary-expressions

  expression:
    - scope: punctuation.delimiter
      match: ','
    - include: assignment-expression

  expressions:
    - scope: punctuation.delimiter
      match: ','
    - include: assignment-expressions
    # - scope: storage.type
    #   match: '\b(?:{{storage_classes}})\b'
    # - scope: keyword
    #   match: '\b(?:{{es17_keywords}})\b'
    # - scope: punctuation
    #   match: '(?:{{punctuators}})'
    # - scope: keyword.operator
    #   match: '{{operators}}'
  
  comments:
    - match: /\*\*(?!/)
      scope: punctuation.definition.comment.js
      push:
        - meta_scope: comment.block.documentation.js
        - match: \*/
          scope: punctuation.definition.comment.js
          pop: true
    - match: /\*
      scope: punctuation.definition.comment.js
      push:
        - meta_scope: comment.block.js
        - match: \*/
          scope: punctuation.definition.comment.js
          pop: true
    - match: '//'
      scope: punctuation.definition.comment.js
      push:
        - meta_scope: comment.line.double-slash.js
        - match: \n
          pop: true
  
  literal-string:
    - match: "'"
      scope: punctuation.definition.string.begin.js
      set:
        - meta_scope: string.quoted.single.js
        - match: (')|(\n)
          captures:
            1: punctuation.definition.string.end.js
            2: invalid.illegal.newline.js
          pop: true
        - include: string-content
    - match: '"'
      captures:
        0: punctuation.definition.string.begin.js
      set:
        - meta_scope: string.quoted.double.js
        - match: (")|(\n)
          captures:
            1: punctuation.definition.string.end.js
            2: invalid.illegal.newline.js
          pop: true
        - include: string-content

  literal-string-template:
    - match: '({{identifier}})?(`)'
      captures:
        1: variable.function.tagged-template.js
        2: punctuation.definition.string.template.begin.js
      set:
        - meta_scope: string.template.js
        - match: "`"
          scope: punctuation.definition.string.template.end.js
          pop: true
        - match: '\$\{'
          captures:
            0: punctuation.definition.template-expression.begin.js
          push:
            - meta_scope: meta.template.expression.js
            - meta_content_scope: source.js.embedded.expression
            - match: '\}'
              scope: punctuation.definition.template-expression.end.js
              pop: true
            - include: expressions
        - include: string-content

  literal-number:
    - match: '(?i)(?:\B[-+]|\b)0x[0-9a-f]*\.(\B|\b[0-9]+)'
      scope: invalid.illegal.numeric.hex.js
      pop: true
    - match: '(?:\B[-+]|\b)0[0-9]+\.(\B|\b[0-9]+)'
      scope: invalid.illegal.numeric.octal.js
      pop: true
    - match: |-
        (?xi)
        (?:\B[-+])?
        (?:
          \b0b[0-1]*|                 # binary
          \b0o[0-7]*|                 # octal
          \b0x[0-9a-f]*|              # hex
          (
            \B\.[0-9]+|               # e.g. .999
            \b[0-9]+(\.[0-9]*)?       # e.g. 999.999, 999. or 999
          )(e[-+]?[0-9]+)?            # e.g. e+123, E-123
        )
      scope: constant.numeric.js
      pop: true
    - match: '(?:\B[-+]|\b)(Infinity)\b'
      scope: constant.language.infinity.js
      pop: true

  string-content:
    - match: \\\s*\n
      scope: constant.character.escape.newline.js
    - match: '\\(x[\da-fA-F][\da-fA-F]|u[\da-fA-F][\da-fA-F][\da-fA-F][\da-fA-F]|.)'
      scope: constant.character.escape.js

  regexp-complete:
    - match: '/'
      scope: punctuation.definition.string.begin.js
      set: regexp
    # - match: '/(?=(?:[^/\\\[]|\\.|\[([^\]\\]|\\.)+\])+/(?![/*])[gimy]*(?!\s*[a-zA-Z0-9_$]))'
    #   scope: punctuation.definition.string.begin.js
    #   set: regexp

  regexp:
    - meta_scope: string.regexp.js
    - match: "(/)([gimy]*)"
      captures:
        1: punctuation.definition.string.end.js
        2: keyword.other.js
      pop: true
    - match: '(?=.|\n)'
      push:
        - match: '(?=/)'
          pop: true
        - include: scope:source.regexp.js
  
  constant:
    - match: \btrue\b
      scope: constant.language.boolean.true.js
      pop: true
    - match: \bfalse\b
      scope: constant.language.boolean.false.js
      pop: true
    - match: \bnull\b
      scope: constant.language.null.js
      pop: true
    - match: \bundefined\b
      scope: constant.language.undefined.js
      pop: true
    - match: \bNaN\b
      scope: constant.language.nan.js
      pop: true
